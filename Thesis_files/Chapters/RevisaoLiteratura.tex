%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% RevisaoLiteratura.tex
%% NOVA thesis document file
%%
%% Chapter with content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE RevisaoLiteratura.tex}%

\chapter{Base Teórica e Revisão de Literatura}
\label{cha:revisão_de_literatura}

\prependtographicspath{{Chapters/Figures/Covers/}}

% epigraph configuration
\epigraphfontsize{\small\itshape}
\setlength\epigraphwidth{12.5cm}
\setlength\epigraphrule{0pt}

\section{Extensões, Restrições, e Critérios}
\label{sec:extensões_restrições_critérios}

O problema aqui apresentado pode ser englobado na família de problemas \textit{Job-Shop}, um dos problemas mais estudados na área de investigação operacional.\\
Este problema é definido por um conjunto finito $J$ de trabalhos, um conjunto finito $R$ de recursos, e um conjunto finito $O$ de operações. Cada trabalho $j$ é uma sequência de $n_{j}$ operações consecutivas em $O$, em que cada operação $i \in O$ é processada no recurso $R_{i}$ com duração contínua de $\tau_{i}$ e sem antecipação de operações~\cite{dauzere-peresFlexibleJobShop2024}.\\
Contudo, o problema em estudo não é apenas descrito pela definição clássica de \textit{Job-Shop}. Existe uma grande variedade de extensões, restrições, e critérios que permitem modificar o problema base de forma a ser mais fidedigno ao sistema em estudo. Para tal, o problema em estudo pode ser descrito como \textit{Flexible Multi-Resource Job-Shop with No-Wait}.\\

A extensão \textit{Flexible} foi descrita pela primeira vez por Brucker e Schlie~\cite{bruckerJobshopSchedulingMultipurpose1990} e dado o nome de \textit{Flexible} por Brandimarte~\cite{brandimarteRoutingSchedulingFlexible1993}. Esta adição é uma das mais importantes na generalização do problema \textit{Job-Shop} para o contexto real, existe no entanto o aumento da complexidade e a impossibilidade de utilizar o método tradicional na sua resolução~\cite{dauzere-peresFlexibleJobShop2024}. Existe para cada operação $i \in O$ um conjunto de recursos $R_{i} \subseteq R$ que podem ser utilizados, ou seja, existe um conjunto de recursos-tipo que exercem a mesma função, com duração de $\tau_{i}^{k}$ para o recurso $k \in R_{i}$.\\

A extensão \textit{Multi-Resource} foi descrita pela primeira vez por Brucker e Neyer~\cite{bruckerTabusearchMultimodeJobshop1998} e por Dauzère-Pérès et al.~\cite{dauzere-peresMultiresourceShopScheduling1998}, na qual existe para cada operação $i \in O$, $m(i)$ recursos diferentes, tal que o conjunto $R_{i}^{k}$ contém o $k^{\circ}$ recurso-tipo da operação $O_{i}$, ou seja, cada operação é processada por $m(i)$ recursos-tipo.\\

A restrição \textit{Minimum/Maximum Time Lag} limita o tempo decorrido entre operações sequenciais de um trabalho, sendo \textit{No-Wait} o caso extremo desta restrição, garantindo que não existe tempo de espera entre operações sequenciais. Este conceito foi proposto por Callahan~\cite{callahanNothingHotDelay1971}, tal que o começo da operação $O_{i+1}$ ocorra no mesmo momento que a operação $O_{i}$ termina, caso estas façam parte do mesmo trabalho $j$.\\

Ao mesmo tempo, também é possível resolver o problema apresentado de forma a maximizar ou minimizar diferentes critérios. Estes podem ser baseado em tempo, número de trabalhos, custo, receita, ou impacto no meio ambiente.\\

\section{Abordagens para a Resolução}
\label{sec:abordagens_para_a_resolução}

Existem três categorias gerais para a resolução de problemas \textit{Job-Shop}: algoritmos exatos; heurísticas; e meta-heurísticas~\cite{jiangReviewIntelligentScheduling2023}. De seguida, serão apresentados alguns métodos de resolução do problema \textit{Job-shop} e uma breve descrição de como funcionam.\\

\subsection{Algoritmos Exatos}

Historicamente, a utilização de métodos exatos foi a principal abordagem utilizada, com especial ênfase nos artigos iniciais sobre o problema clássico de \textit{Job-Shop}. A utilização de \textit{Branch and Bound}(\textit{BB}) é a principal abordagem para a resolução deste problema, através de um algoritmo dedicado ou modelado através de \textit{Mixed Integer Linear Programming} (\textit{MILP})~\cite{dauzere-peresFlexibleJobShop2024}.\\
A forma canónica de \textit{Linear Programming} pode ser expressa por:\\
$$\text{Maximizar } z =c_{1}x_{1} + c_{2}x_{2} + \ldots + c_{n}x_{n}$$
Sujeito a:
$$a_{11}x_{1} + a_{12}x_{2} + \ldots + a_{1n}x_{n} \leq b_{1}$$
$$a_{21}x_{2} + a_{22}x_{2} + \ldots + a_{2n}x_{n} \leq b_{2}$$
$$\vdots$$
$$a_{m1}x_{m} + a_{m2}x_{2} + \ldots + a_{mn}x_{n} \leq b_{m}$$
$$x_{j} \geq 0, j=1, \ldots, n$$

Existem vários modelos utilizados para representar um problema \textit{Job-Shop}: o modelo disjuntivo; o modelo indexado no tempo; e o modelo baseado em ordenação~\cite{kuMixedIntegerProgramming2016}.\\

O modelo disjuntivo, ou de Manne~\cite{manneJobShopSchedulingProblem1960} utiliza um grafo denominado $G(V,C \cup D)$, em que $V$ é o conjunto de vértices e que representam as operações dos vários trabalhos, $C$ é o conjunto de arcos conjuntivos que ligam as operações $i$ e $i+1$ de um trabalho, $D$ é o conjunto de arcos disjuntivos que ligam as operações que requerem o mesmo recurso. Desta forma é escolhida a ordem de processamento em cada recurso de forma a cumprir com as restrições e minimizando/maximizando o critério em estudo. O modelo indexado no tempo, ou de Bowman~\cite{bowmanScheduleSequencingProblem1959}, procura definir o instante de início de cada operação, sendo esta a variável de decisão que o modelo utiliza. O modelo baseado em ordenação, ou de Wagner~\cite{wagnerIntegerLinearprogrammingModel1959}, define explicitamente a sequência de operações que devem ocorrer em cada recurso.\\

Caso se formule o problema através de \textit{MILP} será necessário utilizar um \textit{solver}, como o Gurobi ou o CPLEX, que utilizam algoritmos como \textit{BB} ou \textit{Cutting Planes} na resolução do problema. \\

Por sua vez, \textit{Constraint Programming} (\textit{ConP}) tem vindo a ser mais estudo para a resolução destes problemas~\cite{dauzere-peresFlexibleJobShop2024}. Em problemas de escalonamento, utilizam-se variáveis de intervalo com quatro atributos: se um intervalo se encontra na solução, o tempo de início do intervalo, o tempo de término do intervalo, e o tamanho deste~\cite{kasapidisFlexibleJobShop2021}.\\

\subsection{Heurísticas}

Heurísticas são algoritmos que devem permitir a obtenção de uma solução viável de forma rápida, por isso será de esperar que esta abordagem não resulte na obtenção da solução ótima. Frequentemente, a formulação de uma heurística apenas funcionará para o problema para qual foi desenhada, devido à intuição apresentada na sua construção~\cite{ezugwuMetaheuristicsComprehensiveOverview2021}.\\

\subsection{Meta-Heurísticas}

Meta-heurísticas são o meio termo entre a qualidade das soluções apresentadas por algoritmos exatos e a rapidez das heurísticas. Existe uma grande quantidade de abordagens existentes, podem ser baseadas em população, em trajetórias, com memória ou sem, ou baseadas em processos naturais.\\
Algumas das meta-heurísticas com mais impacto são: \textit{Simulated Annealing} (\textit{SA}); \textit{Genetic Algorithm} (\textit{GA}); \textit{Differential Evolution} (\textit{DE}); \textit{Particle Swarm Optimization} (\textit{PSO}); e \textit{Tabu Search} (\textit{TS})~\cite{ezugwuMetaheuristicsComprehensiveOverview2021}. Todas estas meta-heurísticas poderão ser utilizadas para resolver o problemas apresentado.\\

\textit{SA} é uma meta-heurística evolucionária baseada no processo de arrefecimento de metais, em que se verifica uma menor energia do sistema quando este arrefecimento acontece lentamente. Desta forma, a solução $s$ com uma vizinhança $S_{s}$ de onde é gerada uma nova solução $s'$, que será avaliada consoante a função objetivo $f(s')$. A solução $s'$ poderá ser aceite mesmo não apresentando melhor valor, sendo esta a principal diferenciação de outras meta-heurísticas, de acordo com o algoritmo Metropolis~\cite{metropolisEquationStateCalculations1953}:
$$
Pr\{\text{aceitar } s'\}= 
\begin{cases}
	1                         ,& \text{se } f(s')<f(s)\\
    e^{\frac{f(s)-f(s')}{c_{k}}},& \text{caso contrário}
\end{cases}
$$

Onde $c_{k}$ é a temperatura atual. No início do algoritmo, quando a temperatura é alta, existe probabilidade acrescida de aceitar soluções piores, com o arrefecer da temperatura com cada iteração, a probabilidade de aceitar soluções piores que a atual diminui.\\
Também é necessário definir qual a temperatura inicial do algoritmo, como se realiza o arrefecimento de $c_{k}$, quantas vizinhanças procurar por iteração $L_{k}$, e quando se dá por terminado o algoritmo $CP$. Cada vizinho visitado pode, ou não, representar uma solução viável, deve-se ter cuidado na escolha da representação da solução e na geração da vizinhança para garantira a viabilidade da solução, ou possivelmente relaxar certas restrições ao incluir a punição sobre a sua violação na função objetivo.\\

\textit{GA} é uma meta-heurística populacional baseada no conceito de sobrevivência do mais apto. Inicia-se o algoritmo ao gerar vários membros aleatoriamente, tal que cada um seja representado por um cromossoma, a codificação dessa solução. Para a geração de novas soluções ocorre o cruzamento entre membros, normalmente selecionadas entre os melhores, de forma a obter uma nova descendência. A essa descendência ocorre a mutação do cromossoma para que ocorra maior exploração das soluções~\cite{katochReviewGeneticAlgorithm2021}.\\

\textit{DE} é uma meta-heurística populacional também baseada no conceito de sobrevivência do mais apto. Contrariamente a \textit{GA}, nem toda a descendência é aceite e os pais removidos, diminuindo o risco de substituir boas soluções por piores~\cite{shilpaJobShopScheduling2018}. Inicia-se com uma população inicial, de tamanho $NP$, de vetores com valores uniformes entre 0 e 1, tal que $X_{m,n,G}$ seja o valor do vetor $m$ na posição $n$ da iteração $G$. Três vetores $r_{1}$, $r_{2}$ e $r_{3}$ são gerados de forma a que cada seja composto por uma sequência de tamanho $NP$, de seguida o vetor mutante é gerado por:
$$V_{m,n,G}=X_{r_{1},n,G}+F(X_{r_{2},n,G}-X_{r_{3},n,G})$$

Por sua vez os vetores a testar são gerados por:
$$
U_{m,n,G+1}= 
\begin{cases}
	V_{m,n,G}   ,& \text{se } rand()\leq CR\\
    X_{m,n,G}   ,& \text{caso contrário}
\end{cases}
$$

Tendo que $rand()$ seja um valor aleatório uniforme entre 0 e 1, e que $CR$ seja a taxa de aceitação de cruzamento. Num passo seguinte é necessário descodificar a solução gerada para a avaliar, o que depende do problema a resolver~\cite{sriboonchandrImprovedDifferentialEvolution2019}.\\

\textit{PSO} é uma meta-heurística de enxame baseada no comportamento natural de animais de rebanho durante a procura de comida. Para tal são gerados $P$ partículas, tal que a partícula $i$ se encontra na posição $X^{i}(t)$ na iteração $t$, bem como uma velocidade $V^{i}(t)$. Com cada iteração a posição e velocidade de cada partícula é atualizada:
$$X^{i}(t+1)=X^{i}(t)+V^{i}(t+1)$$
$$V^{i}(t+1)=\omega V^{i}(t)+c_{1}r_{1}(pbest^{i}-X^{i}(t))+c_{2}r_{2}(gbest-X^{i}(t))$$

Onde $r_{1}$ e $r_{2}$ são valores aleatórios uniformes entre 0 e 1, $\omega$, $c_{1}$ e $c_{2}$ são os parâmetros da meta-heurística e chamam-se de inércia, coeficiente cognitivo e coeficiente social, respetivamente. $pbest^{i}$ é a melhor solução encontrada pela partícula $i$, $gbest$ é a melhor solução já encontrada~\cite{ParticleSwarmOptimization2025}.\\

\textit{TS} é uma meta-heurística populacional que utiliza memória para guiar a procura. Através de uma solução $x$ um conjunto de soluções vizinhas são geradas através da sua modificação, o melhor vizinho $\tilde{x}$ é comparada com a melhor solução já encontrada, que se torna no ponto de começo da próxima iteração. A lista tabu inclui um conjunto dos últimas movimentos tomados, o que limita os vizinhos que podem ser visitados em cada iteração, ajudando a guiar a procura. Como a lista é de tamanho limitado, os movimentos mais antigos saem e voltam a estar disponíveis.\\

\section{Abordagens para a Resolução}
\label{sec:abordagens_para_a_resolução}

Nesta secção será apresentada uma breve revisão da literatura existente sobre as abordagens para a resolução dos problemas \textit{Job-Shop} e os seus derivados. A literatura aqui apresentada não será exaustiva, mas demonstrará algumas tendências para problemas próximos ao apresentado nesta dissertação.\\
O critério mais estudado nesta área de investigação é a minimização do \textit{makespan}~\cite{xiongSurveyJobShop2022}, tido como o tempo necessário para completar todos os trabalhos, mesmo assim existem alguns critérios diferentes que têm aparecido na literatura. Desta forma, pretende-se dar a conhecer alguns destas outras vertentes.\\

\subsection{Algoritmos Exatos}

Algoritmos exatos foram a principal abordagem utilizada para resolver problemas de \textit{Job-Shop} mas têm vindo a tornar-se menos considerados com o aumento do número de extensões e restrições que os novos problemas apresentam~\cite{jiangReviewIntelligentScheduling2023}.\\

Como já referido, existem três grandes modelos utilizados neste espaço. O modelo disjuntivo, o modelo indexado no tempo, e o modelo baseado em ordenação. Ku e Beck~\cite{kuMixedIntegerProgramming2016} avaliaram os modelos de acordo com a sua eficiência computacional, onde se observa que o modelo disjuntivo é o mais eficiente a resolver problemas \textit{Job-Shop} de pequenas e grandes dimensões. Será razoável esperar que este facto seja verdade para outras vertentes do problema. Ao mesmo tempo comparam as formulação em \textit{MILP} com uma de \textit{ConP}, evidenciando a eficiência deste última.\\

Dauzère-Pérès et al.~\cite{dauzere-peresFlexibleJobShop2024} apresentam uma formulação do modelo disjuntivo utilizando \textit{MILP} para resolver o problema \textit{Flexible Job-Shop} com o objetivo de minimizar o \textit{makespan}, bem como este deve ser modificado de forma a poderem ser adicionadas novas extensões e restrições.\\

Existem também artigos que geram ou criam problemas que se tornam em \textit{benchmarks}, sendo utilizados em vários artigos de forma a comparar resultados. Um exemplo é o conjunto de problemas \textit{Small Size Flexible Job-Shop Scheduling} (\textit{SFJS}) e o conjunto \textit{Medium and Large Size Flexible Job-Shop Scheduling} (\textit{MFJS}) criado por Fattahi et al.~\cite{fattahiMathematicalModelingHeuristic2007}, onde também se apresenta uma formulação para resolver o problema \textit{Flexible Job-Shop}. Em Ozbakir et al.~\cite{ozguvenMathematicalModelsJobshop2010} é apresentada outra formulação baseada no modelo disjuntivo, ao mesmo tempo é comparada com o modelo de Fattahi et al.~\cite{fattahiMathematicalModelingHeuristic2007} em relação à eficiência computacional, verificando que esta formulação é superior na maioria das instâncias. Em Thörnblad et al.~\cite{Thrnblad2013ACI} é apresentada e comparada uma formulação baseada no modelo indexado no tempo, onde se observa a inferior eficiência deste modelo.\\

Samarghandi~\cite{samarghandiSolvingNowaitJob2019} propõe um modelo \textit{MILP} para a resolução do problema \textit{No-wait Job-Shop} com o objetivo de minimizar o \textit{makespan} com a restrição adicional de não ultrapassar a data limite de cada trabalho. Também apresenta dois modelos de \textit{Constraint Programming} que resultam em boas soluções relativamente ao modelo \textit{MILP} em problemas de grande dimensão.\\

Em Behmanesh et al.~\cite{behmaneshImprovedAntColony2021} é apresentado um modelo \textit{MILP} para resolver o problema \textit{Flexible Multi-Resource Job-Shop}.

\subsection{Heurísticas}

A heurística Nawaz-Enscore-Ham (NEH)~\cite{nawazHeuristicAlgorithmMmachine1983} foi desenvolvida para o problema \textit{Flow-Shop}, mas que já foi utilizada em vários artigos, especialmente na criação de soluções iniciais em problemas \textit{Job-Shop}~\cite{yingMinimizingTotalCompletion2022, xuNoWaitJobShop2021}.\\

Um possível relaxamento do problema em estudo, \textit{Blocking No-Wait and Controlable Times} ou \textit{Blocking No-Wait and Maximum Time Lag}, já foi estudado. Em Aschauer et al. ~\cite{aschauerEfficientAlgorithmScheduling2017} é apresentada uma heurística para o sequenciamento de trabalhos e um algoritmo de \textit{timetabling}, apresentando boas soluções em pouco tempo.\\ 

\subsection{Meta-Heurísticas}

Xia e Wu.~\cite{xiaEffectiveHybridOptimization2005} utilizam um algoritmo híbrido entre \textit{PSO} e \textit{SA} na resolução do problema \textit{Flexible Job-Shop} com tempos de processamento diferentes dentro de cada recurso-tipo. Onde \textit{PSO} é utilizada na atribuição de operações às máquinas, enquanto \textit{SA} é utilizada para escalonar operação a cada recurso.\\

Sriboonchandr et al.~\cite{sriboonchandrImprovedDifferentialEvolution2019} utilizam \textit{DE} na resolução do problema \textit{Flexible Job-Shop}, contudo não apresenta a qualidade esperada das soluções.\\

Jonathan et al.~\cite{jonathanWhaleOptimizationAlgorithm2024} comparam quatro meta-heurísticas para resolve o problema \textit{Flexible Flow-Shop with No-Wait}. A meta-heurística proposta, \textit{Whale Optimization Algorithm}, gera solução com qualidade semelhante a \textit{SA}, \textit{GA} e \textit{Minimum Deviation Algorithm}. Esta última demonstra tempo computacional muito menor.\\

Ying e Lin~\cite{yingMinimizingTotalCompletion2022} comparam quatro variantes de \textit{SA} na resolução do problema \textit{Job-Shop with No-Wait} com minimização do tempo total de conclusão. Demonstram que a utilização adicional do retorno e a existência de várias soluções iniciais permitem a obtenção de melhores soluções no mesmo espaço de tempo.\\

Perrachon et al.~\cite{perrachonIndustrialMultiresourceFlexible2025} sugerem a utilização de \textit{SA} para a otimização do problema \textit{Flexible Multi-Resource Job-Shop}. Para tal, são exploradas oito diferentes estruturas da vizinhança baseadas no modelo disjuntivo. A restrição \textit{Blocking} encontra-se relaxada neste problema, ao ser possível que vários recursos sejam necessários durante fases diferentes de cada operação, podendo ser visto como a decomposição da operação em várias partes com a restrição de \textit{No-Wait} entre elas.\\

Caumond et al.~\cite{caumondMemeticAlgorithmJobshop2008} apresentam uma meta-heurística baseada no modelo disjuntivo, utilizando \textit{Memetic Algorithm} para a resolução do problema \textit{Job-Shop with No-Wait} e \textit{Job-Shop with Maximum Time Lag}.\\